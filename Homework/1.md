# Homework 1 - HPC

1. In following program example we were assuming that each call to `Compute_next_value` requires
   roughly the same amount of work in each loop iteration. For your reference:

   ```cpp
   auto my_sum = 0;
   auto my_first_i = /* ... */;
   auto my_last_i = /* ... */;

   for (auto my_i = my_first_i; my_i < my_last_i; my_i++) {
      auto my_x = Compute_next_value(/* ... */);
      my_sum += my_x;
   }
   ```

   Let's now consider instead that a call when $ i = k $ requires $ k + 1 $ units of time as the call
   when $ i = 0 $. Example: if the first call requires 1 millisecond, the second requires 2ms, the
   third requires 3ms, and so on.

   > ![Note]
   > Every process get assigned consecutive iterations in order (exactly like in the example in the
   > slides/book), i.e., process 0 will work on the first few iterations, while processor 1 will on
   > the second set of iterations, etc.

   How much time each core will spend in the loop calling the function `Compute_next_value` if
   $ n = 15 $ and $ p = 3 $? Where $n$ is the number of elements in the loop and $p$ in the number of
   available cores.

   **Answer:**

   I'm not entirely sure where $ k $ comes from to be honest, there's a few ways to interpret it. I
   will ask professor Petruzza what he thinks.

   | Core | Time (ms) |
   | :--: | :-------: |
   |  0   |           |
   |  1   |           |
   |  2   |           |

2. In the previous question, the load among the cores is not balanced anymore. How would you balance
   it?

   Answer devising an algorithm (written in pseudo-code) which produces the following output:

   - An array containing the total amount of time (i.e., ms) spent on each core
   - A bi-dimensional array containing the indices of the iterations ($i$) you assign to each core
   - Finally, report a numerical example (i.e., including the content of the arrays).

   **Answer:**

   _Will update with compiler explorer link once working, again, not sure what it's asking_

   ```cpp
   // p: number of cores
   template<size_t p>
   auto balance_load(const size_t i) -> pair<array<time>, array<array<indices>>>;
   ```

3. Derive formulas for the number of receives and additions that core 0 and core 4 carry out using

   1. the original pseudo-code for a global sum, and
   2. the tree-structured global sum.

   > ![Note]
   > Assume $ n $ (number of cores) is always a power of two. Assume the initial partial sums have
   > already been computed by each core.

   Finally, report the numbers of receives and additions carried out by core 0 and core 4 (in two
   different tables) when the two methods are used with 2, 4, 16, 512 and 1024 cores.

   **Answer:** 
